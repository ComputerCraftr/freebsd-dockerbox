#!/bin/sh

GUEST_ROOT=/usr/local/share/dockerbox

: "${IFCONFIG:=/sbin/ifconfig}"
: "${GREP:=/usr/bin/grep}"
: "${GRUB_BHYVE:=/usr/local/sbin/grub-bhyve}"
: "${BHYVE:=/usr/sbin/bhyve}"
: "${SED:=/usr/bin/sed}"
: "${ECHO:=/bin/echo}"
: "${DAEMON:=/usr/sbin/daemon}"
: "${ROUTE:=/sbin/route}"
: "${PFCTL:=/sbin/pfctl}"
: "${SYSCTL:=/sbin/sysctl}"

: "${DOCKERBOX_IF_PRE:=10.0.0}"
: "${EXT_IF:=vtnet0}"
: "${PF_CONF:=/etc/pf.conf}"

DOCKERBOX_IF=dockerbox0
DOCKERBOX_IF_IP="${DOCKERBOX_IF_PRE}.1"
DOCKERBOX_GATE="${DOCKERBOX_IF_PRE}.0"
DOCKERBOX_ROUTE_MASK=24
DOCKERBOX_IF_IP_MASK="${DOCKERBOX_IF_IP}/${DOCKERBOX_ROUTE_MASK}"
DOCKERBOX_GATE_MASK="${DOCKERBOX_GATE}/${DOCKERBOX_ROUTE_MASK}"
DOCKERBOX_VM=dockerbox
DOCKERBOX_LOG=/var/log/dockerbox.log
DISK_IMAGE="${GUEST_ROOT}/disk.img"
DEVICE_MAP="${GUEST_ROOT}/device.map"

memory=1024M
cpu=1

log() {
    ${ECHO} "$@" >> ${DOCKERBOX_LOG}
}

capture_output() {
    local _type="$1"
    local _id="$2"

    while read -r message; do
        log "${_type}" "[${_id}] ${message}"
    done
}

sysctl_value() {
    ${SYSCTL} -nq "$1"
}

has_bridge_interface() {
    ${IFCONFIG} | ${GREP} -Fq "${DOCKERBOX_IF}: "
}

get_tap_interface() {
    if has_bridge_interface; then
        ${IFCONFIG} "${DOCKERBOX_IF}" | ${GREP} -F member | ${SED} -E 's/^.*member:.*(tap[^ ]*).*$/\1/'
    else
        ${ECHO} ""
    fi
}

check_ext_if() {
    ${IFCONFIG} | ${GREP} ${EXT_IF} -c
}

check_pf() {
    local _nat_cnt

    if [ ! $(${PFCTL} -s Running) == "Enabled" ]; then
        log info "Enabling PF"
        ${PFCTL} -e #| capture_output debug pfctl
    fi

    _nat_cnt=$(${PFCTL} -s nat | grep nat | grep ${DOCKERBOX_GATE_MASK} | grep ${EXT_IF} -c)
    if [ $_nat_cnt -lt 1 ]; then
        log warn "No pf NAT set up"
        if [ $(check_ext_if) -lt 1 ]; then
            log warn "External interface specified in settings not available"
        else
            log info "Adding pf NAT"
            ${ECHO} "nat on ${EXT_IF} inet from ${DOCKERBOX_GATE_MASK} to any -> (${EXT_IF})" >> ${PF_CONF}
            ${PFCTL} -d #> /dev/null #| capture_output debug pfctl
            ${PFCTL} -e -f ${PF_CONF} #> /dev/null #| capture_output debug pfctl
        fi
    fi
}

check_bridge() {
    if ! has_bridge_interface; then
        log info "Creating bridge interface: ${DOCKERBOX_IF}"
        ${IFCONFIG} bridge create name ${DOCKERBOX_IF} up 2>&1 | capture_output debug ifconfig
    else
        log warn "Bridge interface already exists: ${DOCKERBOX_IF}, skipping creation"
    fi

    ${IFCONFIG} ${DOCKERBOX_IF} inet ${DOCKERBOX_IF_IP_MASK}
    #if [ ! $(${ROUTE} get ${DOCKERBOX_IF_PRE}.3 | grep interface | cut -d' ' -f 2) == ${DOCKERBOX_IF} ]; then
    ${ROUTE} add -net ${DOCKERBOX_IF_IP} ${DOCKERBOX_GATE} ${DOCKERBOX_ROUTE_MASK} | capture_output debug route
    #fi

    ${IFCONFIG} ${DOCKERBOX_IF} group viid-4c918@
    ${IFCONFIG} ${DOCKERBOX_IF} group vm-switch
}

check_tap() {
    local _tap="$(get_tap_interface)"

    if [ -z "${_tap}" ]; then
        _tap="$(${IFCONFIG} tap create up)"
        log info "Linking tap interface to ${DOCKERBOX_IF}: ${_tap}"
        ${IFCONFIG} ${DOCKERBOX_IF} addm "${_tap}" 2>&1 | capture_output debug ifconfig
    else
        log warn "Linked tap interface already exists: ${_tap}, skipping creation"
    fi
}

check_nat() {
    if [ $(sysctl_value net.inet.ip.forwarding) -eq 0 ]; then
        ${SYSCTL} net.inet.ip.forwarding=1 | capture_output debug sysctl
    fi
    check_bridge
    check_tap
    check_pf
}

destroy_bridge() {
    local _tap

    _tap="$(get_tap_interface)"

    log info "Destroying bridge interface: ${DOCKERBOX_IF}"
    ${IFCONFIG} ${DOCKERBOX_IF} destroy 2>&1 | capture_output debug ifconfig

    if [ -n "${_tap}" ]; then
        log info "Destroying linked tap interface: ${_tap}"
        ${IFCONFIG} "${_tap}" destroy 2>&1 | capture_output debug ifconfig
    else
        log warn "No linked tap inteface found for ${DOCKERBOX_IF}"
    fi
}

dockerbox_start() {
    check_nat 
    local _tap="$(get_tap_interface)"
    #grub-bhyve -m ${DEVICE_MAP} -r hd0,msdos2 -M ${memory} ${DOCKERBOX_VM} 2>&1 | capture_output debug grub-bhyve 
    #${BHYVE} -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,${_tap} -s 3:0,virtio-blk,${DISK_IMAGE} -c ${cpu} -m ${memory} ${DOCKERBOX_VM} 2>&1 | capture_output debug bhyve
    grub-bhyve -m ${DEVICE_MAP} -r hd0,msdos2 -M ${memory} ${DOCKERBOX_VM} #2>&1 | capture_output debug grub-bhyve 
    ${BHYVE} -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,${_tap} -s 3:0,virtio-blk,${DISK_IMAGE} -l com1,stdio -c ${cpu} -m ${memory} ${DOCKERBOX_VM} #2>&1 | capture_output debug bhyve
}

dockerbox_stop() {
    local _tap
    bhyvectl --destroy --vm=${DOCKERBOX_VM}
    destroy_bridge
}

#[ "$0" != "${SCRIPT}" ] && return 0

#log debug "Program started as $0, with arguments: $*"
command="$1"
shift

case ${command} in
    start) dockerbox_start "$@";;
    stop) dockerbox_stop "$@";;
esac
